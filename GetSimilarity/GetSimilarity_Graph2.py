# -*- coding: utf-8 -*- #
 
# ------------------------------------------------------------------
# File Name:        codeSimilarV1.py
# Author:           km
# Version:          ver1.0
# Created:          2022/05/11
# Description:      SSEPRW17 code similarity compare
# Input:            CFG (dot file) of Java source code generated by joern
# Output:           1. Feature vector/centroid CenList corresponding to the CFG  2. Similarity between CenList1 and CenList2, and final judgment result codeSimilar(True/False)
# ------------------------------------------------------------------
import networkx as nx
import numpy as np
import os
from tarjan import tarjan
import sys
import pickle


def cfgReadDotFile (dotFile):
    CFG1 = nx.drawing.nx_pydot.read_dot(dotFile)
    CFG2 = nx.DiGraph(CFG1)
    if '\\n' in CFG2.nodes():
        CFG2.remove_node('\\n')

    entry_node = []
    for node,indegree in CFG2.in_degree():
        if indegree == 0:
            entry_node.append(node)
    if len(entry_node) > 1:
        CFG2.add_node('0')
        CFG2.nodes['0']['label'] = '"-1"'
        for node in entry_node:
            CFG2.add_edge('0',node)   
    nodes = CFG2.nodes()
    edges = CFG2.edges()
    return CFG2,nodes,edges

def extractNodes(CFG):
    nodes = CFG.nodes()
    return nodes

def extractEdges(CFG):
    edges = CFG.edges()
    return edges

def nodeOutDegreeDictGen(nodes,edges):
    nodeOutDict = {} # record outgoing edges degree
    nodeOutDegree = []
    for node in nodes:
        outDegree = 0
        for edge in edges:
            if (node == edge[0]):
                outDegree += 1
        nodeOutDict[node] = outDegree
        nodeOutDegree.append(outDegree)
    return nodeOutDict,nodeOutDegree


# Outgoing edges for each node (actually better to use adjacency matrix)
def nodeOutEdgesGen(nodes,edges):
    nodeList = list(nodes)
    
    nodeEdge = []  # If [[]], the program will consider the first sub-array as empty
    nodeEdgeArr = []
    nodeOutIndexList = []
    nodeOutIndexTemp = []
    
    for node in nodes:
        for edge in edges:
            if (node == edge[0]):
                nodeEdgeArr.append(edge[1])
                nodeOutIndexTemp.append(nodeList.index(edge[1]))
                
        nodeEdge.append(nodeEdgeArr)
        nodeOutIndexList.append(nodeOutIndexTemp)
        # reset to zero
        nodeEdgeArr = []
        nodeOutIndexTemp = []
    # print(nodeOutIndexList)
    return nodeEdge,nodeOutIndexList

# Adjacency matrix generation
def adjMatrixGen(nodes,edges):
    adjMatrix = np.zeros([len(nodes),len(nodes)] , dtype=int)
    i, j = 0, 0
    for node1 in nodes:
        for node2 in nodes:
            for edge in edges:
                if (node1 == edge[0] and node2 == edge[1]):
                    adjMatrix[i,j] = 1           
            j += 1       
        i += 1
        j = 0
        
    return adjMatrix

# dfs to find adjMatrix digraph
def dfsGraph (cfg):
    pass


#cdd Dfs Traversal
def cddDfs(CandiStack, nodeVisit, nodeTraversalList, nodeOutIndexList, nodeOutDegree):
 
    if ( len(CandiStack) == 0 ): #stack empty , dfs over
        return None
    
    else:
        #print("dfs-loop")
        next = CandiStack.pop()  #nextNode
        #print(next)
        
        if (nodeVisit[next] == 1):
            # return None #has been visited
            cddDfs(CandiStack, nodeVisit, nodeTraversalList, nodeOutIndexList, nodeOutDegree)
        else:
            nodeVisit[next] = 1
            # print(next)
            nodeTraversalList.append(next)  #add node 
            
            # push child nodes to Stack
            if ( len(nodeOutIndexList[next]) == 0):
                cddDfs(CandiStack, nodeVisit, nodeTraversalList, nodeOutIndexList, nodeOutDegree) # continue DFS recursion
                #return None  #reach leaf node 
            else:
                childNode = nodeOutIndexList[nodeTraversalList[-1]]
                childNodeDegree = []
                # [x for _,x in sorted(zip(Y,X))] sort X according to Y's order
                for node in childNode:
                    childNodeDegree.append(nodeOutDegree[node])
                
                childNodeSort = [x for _, x in sorted(zip(childNodeDegree, childNode))] # ascending order, node with most branches pops last
                #print(childNodeSort)
                CandiStack.extend(childNodeSort)  #push to stack
                #print(CandiStack)

            cddDfs(CandiStack, nodeVisit, nodeTraversalList, nodeOutIndexList, nodeOutDegree)
    return


# CDD traversal initialization
def dfsInit (adjMatrix, CandiStack):
    # print(adjMatrix)
    lenNodes = len(adjMatrix)
    # indgree = []
    sum = 0
    entry = -1
    # find entry node
    for j in range(0, lenNodes):    
        for i in range(0, lenNodes):
            sum += adjMatrix[i,j]
        if (sum == 0):
            entry = j
            # indgree.append(j)
            break
        sum = 0
    CandiStack.append(entry)
    # print(CandiStack)
    #nodeVisit[entry] = 1 #entry have been visisted
    return 

# Count Centroid of a Cfg
def CentroidGen(nodes, adjMatrix, axisW, axisX, axisY, axisZ):
    sumX,sumY,sumZ,sumW = 0,0,0,0
    n = len(nodes)
    for i in range(0,n):
        for j in range(0,n):
            if (adjMatrix[i,j] == 1):
                sumW += ( axisW[i] + axisW[j] )
                sumX += ( (axisX[i] * axisW[i]) + (axisX[j] * axisW[j]) )
                sumY += ( (axisY[i] * axisW[i]) + (axisY[j] * axisW[j]) )
                sumZ += ( (axisZ[i] * axisW[i]) + (axisZ[j] * axisW[j]) )
    CenX = (sumX / sumW)
    CenY = (sumY / sumW)
    CenZ = (sumZ / sumW)
    CenW = sumW
    
    CenList = []
    CenList.extend((CenX, CenY, CenZ, CenW))
    return CenList
    #return CenX, CenY, CenZ, CenW


# compare similarity between two cfg
def CompareSimilar(Cen1, Cen2, cThreshold):
    similar = 0.0
    similarList = []
    for i in range(0,4):
        if (Cen1[i] + Cen2[i]) == 0: #avoid divide by zero
            temp = 0.0
        else:
            temp = ( abs(Cen1[i] - Cen2[i]) / (Cen1[i] + Cen2[i]) )
        similarList.append(temp)
    
    similar = max(similarList)
    similarFlag = (similar < cThreshold)
    
    return similarList, similar, similarFlag    


#Gen tarjan Dict ,and compute loop depth
def tarjanGen(nodes, adjMatrix):
    # example {1:[2],2:[1,5],3:[4],4:[3,5],5:[6],6:[7],7:[8],8:[6,9],9:[]}
    tarjanDict = {}
    n = len(nodes)
    nodeZ = [0]*len(nodes)
    
    for i in range(n):
        listTemp = []
        
        for j in range(n):
            if ( adjMatrix[i,j] == 1 ):
                listTemp.append(j)  
        tarjanDict[i] = listTemp          
    
    connectGraList = tarjan(tarjanDict)   #compute connected Graph of CFG
    
    ####### Calculate loop depth #####
    for conG in connectGraList:
        if ( len(conG) > 1 ):
            for index in conG:
                nodeZ[index] += 1
                
    # For nested loops, depth value needs to be increased further
    for conG1 in connectGraList:
        for conG2 in connectGraList:
            # If conG2 is a subset of conG1, depth continues to increase
            if ( set(conG2).issubset(set(conG1)) ):
                for index in conG2:
                    nodeZ[index] += 1
                              
    return tarjanDict, connectGraList, nodeZ 

def listdir(path, list_name):  # Pass in the storage list
    for file in os.listdir(path):
        file_path = os.path.join(path, file)
        if os.path.isdir(file_path):
            listdir(file_path, list_name)
        else:
            list_name.append(file)

def Cosine_sim(vec1,vec2):
    dot = sum(a*b for a,b in zip(vec1,vec2))
    norm1 = sum(a*a for a in vec1) ** 0.5
    norm2 = sum(b*b for b in vec2) ** 0.5
    cos_sim = dot/(norm1 * norm2)
    return cos_sim

def Centroids(f1, f2):
    file1name = f1.split('/')[-1]
    file2name = f2.split('/')[-1]
    cfg1name = file1name.split('.')[0] + '.dot'
    cfg2name = file2name.split('.')[0] + '.dot'
    dotdict = os.path.abspath(".") + '/cfg-dot/'
    if os.path.exists(dotdict):
        pass
    else:
        os.mkdir(dotdict)

    existdot = []
    listdir(dotdict, existdot)


    dotFileName1 = dotdict + cfg1name
    cfg1, nodes1, edges1 = cfgReadDotFile(dotFileName1)

    ##############################
    ### Traversal and similarity calculation data
    nodeTraversalList1 = []
    CandiStack1 = []  # Candidate nodes
    nodeVisit1 = [0] * len(nodes1)
    # dfsOff = 0  #dfs FLag , set 1 to stop

    ############################
    nodeOutDict1, nodeOutDegree1 = nodeOutDegreeDictGen(nodes1, edges1)
    nodeOutEdgesList1, nodeOutIndexList1 = nodeOutEdgesGen(nodes1, edges1)


    adjMatrix1 = adjMatrixGen(nodes1, edges1)

    ############
    dfsInit(adjMatrix1, CandiStack1)
    cddDfs(CandiStack1, nodeVisit1, nodeTraversalList1, nodeOutIndexList1, nodeOutDegree1)

    nodeNum1 = []  # Node number, i.e., X coordinate
    # print(nodeTraversalList1)
    for i in range(0, len(nodes1)):
        # print(nodeTraversalList1.index(i))
        nodeNum1.append(nodeTraversalList1.index(i))

    ##### Calculate loop-depth, i.e., Z coordinate

    tarjanDict1, connectGraList1, nodeZ1 = tarjanGen(nodes1, adjMatrix1)

    ##### Calculate centroid
    axisW1 = [1] * len(nodes1)

    axisX1 = nodeNum1
    axisY1 = nodeOutDegree1
    axisZ1 = nodeZ1

    CenList1 = CentroidGen(nodes1, adjMatrix1, axisW1, axisX1, axisY1, axisZ1)
    #print("CenList:\n", CenList1)

    dotFileName2 = dotdict + cfg2name
    cfg2, nodes2, edges2 = cfgReadDotFile(dotFileName2)

    ##############################
    ### Traversal and similarity calculation data
    nodeTraversalList2 = []
    CandiStack2 = []  # Candidate nodes
    nodeVisit2 = [0] * len(nodes2)
    # dfsOff = 0  #dfs FLag , set 1 to stop
    ############################
    nodeOutDict2, nodeOutDegree2 = nodeOutDegreeDictGen(nodes2, edges2)

    nodeOutEdgesList2, nodeOutIndexList2 = nodeOutEdgesGen(nodes2, edges2)

    adjMatrix2 = adjMatrixGen(nodes2, edges2)

    ############
    dfsInit(adjMatrix2, CandiStack2)
    cddDfs(CandiStack2, nodeVisit2, nodeTraversalList2, nodeOutIndexList2, nodeOutDegree2)

    nodeNum2 = []  # Node number, i.e., X coordinate
    for i in range(0, len(nodes2)):
        nodeNum2.append(nodeTraversalList2.index(i))

    ##### Calculate loop-depth, i.e., Z coordinate

    tarjanDict2, connectGraList2, nodeZ2 = tarjanGen(nodes2, adjMatrix2)

    ##### Calculate centroid
    axisW2 = [1] * len(nodes2)

    axisX2 = nodeNum2
    axisY2 = nodeOutDegree2
    axisZ2 = nodeZ2

    CenList2 = CentroidGen(nodes2, adjMatrix2, axisW2, axisX2, axisY2, axisZ2)
    cThreshold = 0.4  # cThreshold set to 0.4 according to SSEPRW17 paper, i.e., similarity below 0.4 is considered similar
    similarList, similar, similarFlag = CompareSimilar(CenList1, CenList2, cThreshold)

    print(1-similar)
    return (1 - similar)#,size

if __name__ == "__main__":

    #print("*************************extract centroid of cfg**********************************")
    dotFileName1 = "./pairs/pair11/0-cfg.dot"